"""
Plot q–p stress trajectories from a dataset generated by the TI-MCC small-strain
stress update. The script loads an NPZ file containing Cauchy stresses `sig`
(and optionally `phase`) and produces a figure showing p–q paths for selected
specimens, with plastic segments highlighted if available.

Trajectories can be subsampled, filtered to only specimens exhibiting
plasticity, and thinned in time. The output is a PNG image saved to the path
given by `--out`.

Usage:
    python qp_plot.py --data data_stress_strain_random_walk.npz
    python qp_plot.py --data data.npz --max 25 --thin 5 --out fig.png
"""
import argparse, numpy as np, matplotlib.pyplot as plt
from pathlib import Path

def p_q_from_voigt(sig):
    """
    Compute mean stress p and deviatoric invariant q from Voigt stress (…,6). 
    Supports arbitrary leading dimensions. 
    Returns arrays with the same leading shape.
    """
    s = sig.reshape(-1,6)                                             # (m*T, 6)
    p = (s[:,0]+s[:,1]+s[:,2])/3.0                                    # (m*T,)
    sxx,syy,szz = s[:,0]-p, s[:,1]-p, s[:,2]-p
    s2 = sxx**2+syy**2+szz**2 + 2.0*(s[:,3]**2+s[:,4]**2+s[:,5]**2)
    q = np.sqrt(1.5*s2)                                               # (m*T,)
    return p.reshape(sig.shape[:-1]), q.reshape(sig.shape[:-1])       # (m, T)

def compute_mcc_ellipse(M: float, pc: float, n_points: int = 300):
    """
    Compute (p, q) arrays for an MCC ellipse in the p–q plane for given M, pc.

    Uses the isotropic MCC form
        (1/(2 M^2)) q^2 + p(p - pc) = 0  =>  q^2 = -2 M^2 p (p - pc),
    and returns only the positive-q branch.
    """
    # Ellipse exists between p = 0 and p = pc (pc < 0 in your convention).
    p_min = min(0.0, pc)
    p_max = max(0.0, pc)
    p_ell = np.linspace(p_max, p_min, n_points)  # from 0 down to pc if pc<0

    q2_ell = (M**2) * p_ell * (p_ell - pc)
    q2_ell = np.maximum(q2_ell, 0.0)
    q_ell = np.sqrt(q2_ell)

    return p_ell, q_ell

def show_quadrant_II(ax, pad=0.05):
    """
    Crop an Axes to Quadrant II (x<0, y>0) based on what's already plotted.
    pad is a fractional padding of the data span.
    """
    # collect all line data on this axes
    xs, ys = [], []
    for ln in ax.lines:
        x, y = ln.get_xdata(), ln.get_ydata()
        if x is None or y is None or len(x) == 0:
            continue
        xs.append(np.asarray(x))
        ys.append(np.asarray(y))
    if not xs:  # nothing plotted
        ax.set_xlim(-1, 0)
        ax.set_ylim(0, 1)
        return

    X = np.concatenate(xs)
    Y = np.concatenate(ys)

    # focus on Q2 if any points exist there; otherwise use all and still crop to Q2
    mask = (X < 0) & (Y > 0)
    if np.any(mask):
        X2, Y2 = X[mask], Y[mask]
    else:
        X2, Y2 = X, Y

    xmin = X2.min()
    xmax = 0.0
    ymin = 0.0
    ymax = Y2.max()
    xspan = abs(xmin - xmax)
    yspan = abs(ymax - ymin)
    ax.set_xlim(xmin - pad*xspan, xmax + pad*xspan)
    ax.set_ylim(ymin - pad*yspan, ymax + pad*yspan)

    ax.set_aspect("equal", adjustable="box")

def main():
    ap = argparse.ArgumentParser("Plot q–p trajectories; optionally only specimens with plastic steps.")
    ap.add_argument("--data", type=Path, required=True)
    ap.add_argument("--out",  type=Path, default=Path("qp_paths.png"))
    ap.add_argument("--max",  type=int,  default=50)
    ap.add_argument("--seed", type=int,  default=0)
    ap.add_argument("--alpha", type=float, default=0.9)
    ap.add_argument("--alpha_plastic", type=float, default=1.0)
    ap.add_argument("--lw", type=float, default=1.2)
    ap.add_argument("--M",  type=float, default=2.0, help="MCC slope parameter M (default: 2.0)")
    ap.add_argument("--pc", type=float, default=-6.0, help="MCC preconsolidation pressure pc (default: -6.0)")
    args = ap.parse_args()

    d = np.load(args.data, allow_pickle=True)
    if "sig" not in d.files: 
        raise KeyError(f"'sig' missing; keys: {d.files}")
    sig = d["sig"]                    # (m, T, 6) make mistakes. Check important info.
    if sig.ndim!=3 or sig.shape[-1]!=6: 
        raise ValueError(f"sig shape {sig.shape} not (m, T, 6)")
    m, T, _ = sig.shape
    p, q = p_q_from_voigt(sig)        # (m, T)
    keep = np.arange(m)
    rng = np.random.default_rng(args.seed)
    idxs = rng.choice(keep, size=min(keep.size, args.max), replace=False) if keep.size>args.max else keep

    fig, ax = plt.subplots(figsize=(7,5))

    # MCC ellipse
    p_ell, q_ell = compute_mcc_ellipse(args.M, args.pc)
    ax.plot(p_ell, q_ell, "k--", lw=2.0,
            label=f"MCC ellipse (M={args.M}, pc={args.pc})")

    # q–p paths
    for i in idxs:
        pi, qi = p[i, :], q[i, :]
        ax.plot(pi, qi, marker="x", ms=1, lw=args.lw, alpha=args.alpha)
        ax.scatter(pi[0],  qi[0],  s=20, marker="o", color="blue")
        ax.scatter(pi[-1], qi[-1], s=20, marker="s", color="red")

    # Labels, layout
    ax.set_title(f"q–p Trajectories ({len(idxs)}/{m})")
    ax.set_xlabel("p (mean stress)")
    ax.set_ylabel("q (deviatoric stress)")
    ax.grid(True, alpha=0.2)
    fig.tight_layout()

    # Now you CAN call this:
    show_quadrant_II(ax)

    # Save
    args.out.parent.mkdir(parents=True, exist_ok=True)
    fig.savefig(args.out, dpi=200)
    print(f"Saved {args.out}")


if __name__ == "__main__":
    main()
